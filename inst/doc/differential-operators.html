<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Differential operators in arbitrary orthogonal coordinates systems</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Differential operators in arbitrary
orthogonal coordinates systems</h1>



<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(calculus)</span></code></pre></div>
<p>Orthogonal coordinates are a special but extremely common case of
curvilinear coordinates where the coordinate surfaces all meet at right
angles. The chief advantage of non-Cartesian coordinates is that they
can be chosen to match the symmetry of the problem. For example,
spherical coordinates are the most common curvilinear coordinate systems
and are used in Earth sciences, cartography, quantum mechanics,
relativity, and engineering.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> These coordinates may be derived from a set
of Cartesian coordinates by using a transformation that is locally
invertible (a one-to-one map) at each point. This means that one can
convert a point given in a Cartesian coordinate system to its
curvilinear coordinates and back. Differential operators such as the
gradient, divergence, curl, and Laplacian can be transformed from one
coordinate system to another via the usage of scale factors.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> The
package implements these operators in Cartesian, polar, spherical,
cylindrical, parabolic coordinates, and supports arbitrary orthogonal
coordinates systems defined by custom scale factors.</p>
<table>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th>Curvilinear coordinates <span class="math inline">\((q_1, q_2,
q_3)\)</span></th>
<th>Transformation from cartesian <span class="math inline">\((x, y,
z)\)</span></th>
<th>Scale factors</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Spherical polar coordinates <span class="math inline">\((r,\theta
,\phi )\)</span></td>
<td><span class="math inline">\({\begin{aligned}x&amp;=r\sin \theta \cos
\phi \\y&amp;=r\sin \theta \sin \phi \\z&amp;=r\cos \theta
\end{aligned}}\)</span></td>
<td><span class="math inline">\({\begin{aligned}h_{1}&amp;=1\\h_{2}&amp;=r\\h_{3}&amp;=r\sin
\theta \end{aligned}}\)</span></td>
</tr>
<tr class="even">
<td>Cylindrical polar coordinates <span class="math inline">\((r,\phi
,z)\)</span></td>
<td><span class="math inline">\({\begin{aligned}x&amp;=r\cos \phi
\\y&amp;=r\sin \phi \\z&amp;=z\end{aligned}}\)</span></td>
<td><span class="math inline">\({\begin{aligned}h_{1}&amp;=h_{3}=1\\h_{2}&amp;=r\end{aligned}}\)</span></td>
</tr>
<tr class="odd">
<td>Parabolic coordinates <span class="math inline">\((u,v,\phi
)\)</span></td>
<td><span class="math inline">\({\begin{aligned}x&amp;=uv\cos \phi
\\y&amp;=uv\sin \phi \\z&amp;={\frac
{1}{2}}(u^{2}-v^{2})\end{aligned}}\)</span></td>
<td><span class="math inline">\({\begin{aligned}h_{1}&amp;=h_{2}={\sqrt
{u^{2}+v^{2}}}\\h_{3}&amp;=uv\end{aligned}}\)</span></td>
</tr>
<tr class="even">
<td>Parabolic cylindrical coordinates <span class="math inline">\((u,v,z)\)</span></td>
<td><span class="math inline">\({\begin{aligned}x&amp;={\frac
{1}{2}}(u^{2}-v^{2})\\y&amp;=uv\\z&amp;=z\end{aligned}}\)</span></td>
<td><span class="math inline">\({\begin{aligned}h_{1}&amp;=h_{2}={\sqrt
{u^{2}+v^{2}}}\\h_{3}&amp;=1\end{aligned}}\)</span></td>
</tr>
</tbody>
</table>
<div id="gradient" class="section level2">
<h2>Gradient</h2>
<p>The gradient of a scalar-valued function <span class="math inline">\(F\)</span> is the vector <span class="math inline">\((\nabla F)_i\)</span> whose components are the
partial derivatives of <span class="math inline">\(F\)</span> with
respect to each variable <span class="math inline">\(i\)</span>. In
arbitrary orthogonal coordinate systems, the gradient is expressed in
terms of the scale factors <span class="math inline">\(h_i\)</span> as
follows:</p>
<p><span class="math display">\[(\nabla F)_i =
\frac{1}{h_i}\partial_iF\]</span></p>
<p>The function <a href="https://calculus.guidotti.dev/reference/gradient.html"><code>gradient</code></a>
implements the symbolic and numeric gradient of <code>functions</code>,
<code>expressions</code> and <code>characters</code>. In Cartesian
coordinates:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gradient</span>(<span class="st">&quot;x*y*z&quot;</span>, <span class="at">var =</span> <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;y * z&quot; &quot;x * z&quot; &quot;x * y&quot;</span></span></code></pre></div>
<p>and in spherical coordinates:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gradient</span>(<span class="st">&quot;x*y*z&quot;</span>, <span class="at">var =</span> <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>,<span class="st">&quot;z&quot;</span>), <span class="at">coordinates =</span> <span class="st">&quot;spherical&quot;</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;1/1 * (y * z)&quot;          &quot;1/x * (x * z)&quot;          &quot;1/(x*sin(y)) * (x * y)&quot;</span></span></code></pre></div>
<p>To support arbitrary orthogonal coordinate systems, it is possible to
pass custom scale factors to the argument <code>coordinates</code>. For
instance, the following call is equivalent to the previous example in
spherical coordinates where the scale factors are now explicitly
specified:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gradient</span>(<span class="st">&quot;x*y*z&quot;</span>, <span class="at">var =</span> <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>,<span class="st">&quot;z&quot;</span>), <span class="at">coordinates =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="st">&quot;x&quot;</span>,<span class="st">&quot;x*sin(y)&quot;</span>))</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;1/(1) * (y * z)&quot;        &quot;1/(x) * (x * z)&quot;        &quot;1/(x*sin(y)) * (x * y)&quot;</span></span></code></pre></div>
<p>Numerical methods are applied when working with
<code>functions</code> with the same sintax introduced for <a href="https://calculus.guidotti.dev/reference/derivative.html">derivatives</a>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="cf">function</span>(x, y, z) x<span class="sc">*</span>y<span class="sc">*</span>z</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gradient</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="at">x =</span> <span class="dv">1</span>, <span class="at">y =</span> pi<span class="sc">/</span><span class="dv">2</span>, <span class="at">z =</span> <span class="dv">0</span>), <span class="at">coordinates =</span> <span class="st">&quot;spherical&quot;</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.000000 0.000000 1.570796</span></span></code></pre></div>
<p>or in vectorized form:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="cf">function</span>(x) x[<span class="dv">1</span>]<span class="sc">*</span>x[<span class="dv">2</span>]<span class="sc">*</span>x[<span class="dv">3</span>]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gradient</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="dv">1</span>, pi<span class="sc">/</span><span class="dv">2</span>, <span class="dv">0</span>), <span class="at">coordinates =</span> <span class="st">&quot;spherical&quot;</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.000000 0.000000 1.570796</span></span></code></pre></div>
<p>When the function <span class="math inline">\(F\)</span> is a
tensor-valued function <span class="math inline">\(F_{d_1,\dots,d_n}\)</span>, the gradient is
computed for each scalar component.</p>
<p><span class="math display">\[(\nabla F_{d_1,\dots,d_n})_i =
\frac{1}{h_i}\partial_iF_{d_1,\dots,d_n}\]</span></p>
<p>In particular, this reduces to the Jacobian matrix for vector-valued
functions <span class="math inline">\(F_{d_1}\)</span>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">c</span>(<span class="fu">prod</span>(x), <span class="fu">sum</span>(x))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gradient</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>))</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3]</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    2    3    6</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]    1    1    1</span></span></code></pre></div>
<p>that may be expressed in arbitrary orthogonal coordinate systems.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">c</span>(<span class="fu">prod</span>(x), <span class="fu">sum</span>(x))</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gradient</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>), <span class="at">coordinates =</span> <span class="st">&quot;cylindrical&quot;</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]      [,2] [,3]</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    2 1.0000000    6</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]    1 0.3333333    1</span></span></code></pre></div>
<div id="jacobian" class="section level3">
<h3>Jacobian</h3>
<p>The function <a href="https://calculus.guidotti.dev/reference/jacobian.html"><code>jacobian</code></a>
is a wrapper for <a href="https://calculus.guidotti.dev/reference/gradient.html"><code>gradient</code></a>
that always returns the Jacobian as a matrix, even in the case of
unidimensional scalar-valued functions.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="cf">function</span>(x) x<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">jacobian</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="dv">1</span>))</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    2</span></span></code></pre></div>
</div>
<div id="hessian" class="section level3">
<h3>Hessian</h3>
<p>In Cartesian coordinates, the Hessian of a scalar-valued function
<span class="math inline">\(F\)</span> is the square matrix of
second-order partial derivatives:</p>
<p><span class="math display">\[(H(F))_{ij} =
\partial_{ij}F\]</span></p>
<p>It might be tempting to apply the definition of the Hessian as the
Jacobian of the gradient to write it in terms of the scale factors.
However, this results in a Hessian matrix that is not symmetric and
ignores the distinction between vector and covectors in tensor analysis.
The generalization to arbitrary coordinate system is not implemented and
only Cartesian coordinates are supported:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="cf">function</span>(x, y, z) x<span class="sc">*</span>y<span class="sc">*</span>z</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">hessian</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="at">x =</span> <span class="dv">3</span>, <span class="at">y =</span> <span class="dv">2</span>, <span class="at">z =</span> <span class="dv">1</span>))</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;               [,1]          [,2]          [,3]</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] -1.918057e-11  1.000000e+00  2.000000e+00</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]  1.000000e+00 -4.315627e-11  3.000000e+00</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]  2.000000e+00  3.000000e+00 -1.726251e-10</span></span></code></pre></div>
<p>When the function <span class="math inline">\(F\)</span> is a
tensor-valued function <span class="math inline">\(F_{d_1,\dots,d_n}\)</span>, the <a href="https://calculus.guidotti.dev/reference/hessian.html"><code>hessian</code></a>
is computed for each scalar component.</p>
<p><span class="math display">\[(H(F_{d_1,\dots,d_n}))_{ij} =
\partial_{ij}F_{d_1,\dots,d_n}\]</span></p>
<p>In this case, the function returns an <code>array</code> of Hessian
matrices:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="cf">function</span>(x, y, z) <span class="fu">c</span>(x<span class="sc">*</span>y<span class="sc">*</span>z, x<span class="sc">+</span>y<span class="sc">+</span>z)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>h <span class="ot">&lt;-</span> <span class="fu">hessian</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="at">x =</span> <span class="dv">3</span>, <span class="at">y =</span> <span class="dv">2</span>, <span class="at">z =</span> <span class="dv">1</span>))</span></code></pre></div>
<p>that can be extracted with the corresponding indices.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>h[<span class="dv">1</span>,,]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;               [,1]          [,2]          [,3]</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] -1.918057e-11  1.000000e+00  2.000000e+00</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]  1.000000e+00 -4.315627e-11  3.000000e+00</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]  2.000000e+00  3.000000e+00 -1.726251e-10</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>h[<span class="dv">2</span>,,]</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;               [,1]          [,2]          [,3]</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] -4.242789e-12  2.932800e-12 -8.683390e-12</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]  2.932800e-12 -7.066143e-11  2.825347e-12</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,] -8.683390e-12  2.825347e-12 -1.848667e-10</span></span></code></pre></div>
</div>
</div>
<div id="divergence" class="section level2">
<h2>Divergence</h2>
<p>The divergence of a vector-valued function <span class="math inline">\(F_i\)</span> produces a scalar value <span class="math inline">\(\nabla \cdot F\)</span> representing the volume
density of the outward flux of the vector field from an infinitesimal
volume around a given point.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> In terms of scale factors, it is expressed
as follows:</p>
<p><span class="math display">\[\nabla \cdot F =
\frac{1}{J}\sum_i\partial_i\Biggl(\frac{J}{h_i}F_i\Biggl)\]</span></p>
<p>where <span class="math inline">\(J=\prod_ih_i\)</span>. When <span class="math inline">\(F\)</span> is an <code>array</code> of
vector-valued functions <span class="math inline">\(F_{d_1,\dots,d_n,i}\)</span>, the <a href="https://calculus.guidotti.dev/reference/divergence.html"><code>divergence</code></a>
is computed for each vector:</p>
<p><span class="math display">\[(\nabla \cdot F)_{d_1,\dots,d_n} =
\frac{1}{J}\sum_i\partial_i\Biggl(\frac{J}{h_i}F_{d_1,\dots,d_n,i}\Biggl)=\frac{1}{J}\sum_i\partial_i(Jh_i^{-1})F_{d_1,\dots,d_n,i}+Jh_i^{-1}\partial_i(F_{d_1,\dots,d_n,i})\]</span></p>
<p>where the last equality is preferable in practice as the derivatives
of the scale factor can be computed symbolically and the computation of
the derivatives of <span class="math inline">\(F\)</span> is more
efficient than the direct computation of <span class="math inline">\(\partial_i\bigl(\frac{J}{h_i}F_{d_1,\dots,d_n,i}\bigl)\)</span>
via finite differences. In Cartesian coordinates:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;x^2&quot;</span>, <span class="st">&quot;y^2&quot;</span>, <span class="st">&quot;z^2&quot;</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">divergence</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>,<span class="st">&quot;z&quot;</span>))</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;2 * x + 2 * y + 2 * z&quot;</span></span></code></pre></div>
<p>In polar coordinates:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;sqrt(r)/10&quot;</span>, <span class="st">&quot;sqrt(r)&quot;</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fu">divergence</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="st">&quot;r&quot;</span>,<span class="st">&quot;phi&quot;</span>), <span class="at">coordinates =</span> <span class="st">&quot;polar&quot;</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;(0.5 * r^-0.5/10 * r + (sqrt(r)/10)) / (1*r)&quot;</span></span></code></pre></div>
<p>And for tensors of vector-valued functions:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="st">&quot;x^2&quot;</span>,<span class="st">&quot;y^2&quot;</span>,<span class="st">&quot;z^2&quot;</span>,<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>,<span class="st">&quot;z&quot;</span>), <span class="at">nrow =</span> <span class="dv">2</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">divergence</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>,<span class="st">&quot;z&quot;</span>))</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;2 * x + 2 * y + 2 * z&quot; &quot;1 + 1 + 1&quot;</span></span></code></pre></div>
<p>The same syntax holds for <code>functions</code> where numerical
methods are automatically applied:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="cf">function</span>(x,y,z) <span class="fu">matrix</span>(<span class="fu">c</span>(x<span class="sc">^</span><span class="dv">2</span>,y<span class="sc">^</span><span class="dv">2</span>,z<span class="sc">^</span><span class="dv">2</span>,x,y,z), <span class="at">nrow =</span> <span class="dv">2</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">divergence</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="at">x =</span> <span class="dv">0</span>, <span class="at">y =</span> <span class="dv">0</span>, <span class="at">z =</span> <span class="dv">0</span>))</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 3.004132e-21 3.000000e+00</span></span></code></pre></div>
</div>
<div id="curl" class="section level2">
<h2>Curl</h2>
<p>The curl of a vector-valued function <span class="math inline">\(F_i\)</span> at a point is represented by a vector
whose length and direction denote the magnitude and axis of the maximum
circulation.<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> In 2 dimensions, the curl is written in
terms of the scale factors <span class="math inline">\(h\)</span> and
the <a href="https://calculus.guidotti.dev/reference/epsilon.html">Levi-Civita
symbol</a> <span class="math inline">\(\epsilon\)</span> as follows:</p>
<p><span class="math display">\[\nabla \times F =
\frac{1}{h_1h_2}\sum_{ij}\epsilon_{ij}\partial_i\Bigl(h_jF_j\Bigl)=
\frac{1}{h_1h_2}\Biggl(\partial_1\Bigl(h_2F_2\Bigl)-\partial_2\Bigl(h_1F_1\Bigl)\Biggl)\]</span></p>
<p>In 3 dimensions:</p>
<p><span class="math display">\[(\nabla \times F)_k =
\frac{h_k}{J}\sum_{ij}\epsilon_{ijk}\partial_i\Bigl(h_jF_j\Bigl)\]</span></p>
<p>where <span class="math inline">\(J=\prod_i h_i\)</span>. This
suggests to implement the <a href="https://calculus.guidotti.dev/reference/curl.html"><code>curl</code></a>
in <span class="math inline">\(m+2\)</span> dimensions in such a way
that the formula reduces correctly to the previous cases:</p>
<p><span class="math display">\[(\nabla \times F)_{k_1\dots k_m} =
\frac{h_{k_1}\cdots h_{k_m}}{J}\sum_{ij}\epsilon_{ijk_1\dots
k_m}\partial_i\Bigl(h_jF_j\Bigl)\]</span></p>
<p>And in particular, when <span class="math inline">\(F\)</span> is an
<code>array</code> of vector-valued functions <span class="math inline">\(F_{d_1,\dots,d_n,i}\)</span> the <a href="https://calculus.guidotti.dev/reference/curl.html"><code>curl</code></a>
is computed for each vector:</p>
<p><span class="math display">\[
\begin{split}
(\nabla \times F)_{d_1\dots d_n,k_1\dots k_m} &amp; =\\
&amp;=\frac{h_{k_1}\cdots h_{k_m}}{J}\sum_{ij}\epsilon_{ijk_1\dots
k_m}\partial_i\Bigl(h_jF_{d_1\dots d_n,j}\Bigl) \\
&amp;=\sum_{ij}\frac{1}{h_ih_j}\epsilon_{ijk_1\dots
k_m}\partial_i\Bigl(h_jF_{d_1\dots d_n,j}\Bigl) \\
&amp;=\sum_{ij}\frac{1}{h_ih_j}\epsilon_{ijk_1\dots
k_m}\Bigl(\partial_i(h_j)F_{d_1\dots d_n,j}+h_j\partial_i(F_{d_1\dots
d_n,j})\Bigl)
\end{split}
\]</span></p>
<p>where the last equality is preferable in practice as the derivatives
of the scale factor can be computed symbolically and the computation of
the derivatives of <span class="math inline">\(F\)</span> is more
efficient than the direct computation of <span class="math inline">\(\partial_i\bigl(h_jF_{d_1\dots
d_n,j}\bigl)\)</span> via finite differences. In 2-dimensional Cartesian
coordinates:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;x^3*y^2&quot;</span>,<span class="st">&quot;x&quot;</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">curl</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>))</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;(1) * 1 + (x^3 * (2 * y)) * -1&quot;</span></span></code></pre></div>
<p>In 3 dimensions, for an irrotational vector field:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;-y&quot;</span>,<span class="st">&quot;z&quot;</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">curl</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>,<span class="st">&quot;z&quot;</span>))</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;0&quot; &quot;0&quot; &quot;0&quot;</span></span></code></pre></div>
<p>And for tensors of vector-valued functions:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;-y&quot;</span>,<span class="st">&quot;z&quot;</span>,<span class="st">&quot;x^3*y^2&quot;</span>,<span class="st">&quot;x&quot;</span>,<span class="st">&quot;0&quot;</span>), <span class="at">nrow =</span> <span class="dv">2</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">curl</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>,<span class="st">&quot;z&quot;</span>))</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3]                            </span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] &quot;0&quot;  &quot;0&quot;  &quot;0&quot;                             </span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,] &quot;0&quot;  &quot;0&quot;  &quot;(1) * 1 + (x^3 * (2 * y)) * -1&quot;</span></span></code></pre></div>
<p>The same syntax holds for <code>functions</code> where numerical
methods are automatically applied and for arbitrary orthogonal
coordinate systems as shown in the previous sections.</p>
</div>
<div id="laplacian" class="section level2">
<h2>Laplacian</h2>
<p>The Laplacian is a differential operator given by the divergence of
the gradient of a scalar-valued function <span class="math inline">\(F\)</span>, resulting in a scalar value giving the
flux density of the gradient flow of a function. The Laplacian occurs in
differential equations that describe many physical phenomena, such as
electric and gravitational potentials, the diffusion equation for heat
and fluid flow, wave propagation, and quantum mechanics.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> In terms of the scale
factor, the operator is written as:</p>
<p><span class="math display">\[\nabla^2F =
\frac{1}{J}\sum_i\partial_i\Biggl(\frac{J}{h_i^2}\partial_iF\Biggl)\]</span></p>
<p>where <span class="math inline">\(J=\prod_ih_i\)</span>. When the
function <span class="math inline">\(F\)</span> is a tensor-valued
function <span class="math inline">\(F_{d_1,\dots,d_n}\)</span>, the <a href="https://calculus.guidotti.dev/reference/laplacian.html"><code>laplacian</code></a>
is computed for each scalar component:</p>
<p><span class="math display">\[(\nabla^2F)_{d_1\dots d_n} =
\frac{1}{J}\sum_i\partial_i\Biggl(\frac{J}{h_i^2}\partial_iF_{d_1\dots
d_n}\Biggl)=\frac{1}{J}\sum_i\partial_i\Bigl(Jh_i^{-2}\Bigl)\partial_iF_{d_1\dots
d_n}+Jh_i^{-2}\partial^2_iF_{d_1\dots d_n}\]</span></p>
<p>where the last equality is preferable in practice as the derivatives
of the scale factor can be computed symbolically and the computation of
the derivatives of <span class="math inline">\(F\)</span> is more
efficient than the direct computation of <span class="math inline">\(\partial_i\bigl(\frac{J}{h_i^2}\partial_iF\bigl)\)</span>
via finite differences. In Cartesian coordinates:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="st">&quot;x^3+y^3+z^3&quot;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="fu">laplacian</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>,<span class="st">&quot;z&quot;</span>))</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;3 * (2 * x) + 3 * (2 * y) + 3 * (2 * z)&quot;</span></span></code></pre></div>
<p>And for tensors of scalar-valued functions:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="fu">c</span>(<span class="st">&quot;x^3+y^3+z^3&quot;</span>, <span class="st">&quot;x^2+y^2+z^2&quot;</span>, <span class="st">&quot;y^2&quot;</span>, <span class="st">&quot;z*x^2&quot;</span>), <span class="at">dim =</span> <span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="fu">laplacian</span>(f, <span class="at">var =</span> <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>,<span class="st">&quot;z&quot;</span>))</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]                                      [,2]   </span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] &quot;3 * (2 * x) + 3 * (2 * y) + 3 * (2 * z)&quot; &quot;2&quot;    </span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,] &quot;2 + 2 + 2&quot;                               &quot;z * 2&quot;</span></span></code></pre></div>
<p>The same syntax holds for <code>functions</code> where numerical
methods are automatically applied and for arbitrary orthogonal
coordinate systems as shown in the previous sections.</p>
</div>
<div id="cite-as" class="section level2">
<h2>Cite as</h2>
<p><em>Guidotti, E. (2020). “calculus: High dimensional numerical and
symbolic calculus in R”. <a href="https://arxiv.org/abs/2101.00086" class="uri">https://arxiv.org/abs/2101.00086</a></em></p>
<p>A BibTeX entry for LaTeX users is</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode latex"><code class="sourceCode latex"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>@Misc{,</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    title = {calculus: High Dimensional Numerical and Symbolic Calculus in R},</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    author = {Emanuele Guidotti},</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    year = {2020},</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    eprint = {2101.00086},</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    archiveprefix = {arXiv},</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    primaryclass = {cs.MS},</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    url = {https://arxiv.org/abs/2101.00086}</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p><a href="https://en.wikipedia.org/wiki/Curvilinear_coordinates" class="uri">https://en.wikipedia.org/wiki/Curvilinear_coordinates</a><a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p><a href="https://en.wikipedia.org/wiki/Orthogonal_coordinates" class="uri">https://en.wikipedia.org/wiki/Orthogonal_coordinates</a><a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p><a href="https://en.wikipedia.org/wiki/Divergence" class="uri">https://en.wikipedia.org/wiki/Divergence</a><a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p><a href="https://en.wikipedia.org/wiki/Curl_(mathematics)" class="uri">https://en.wikipedia.org/wiki/Curl_(mathematics)</a><a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p><a href="https://en.wikipedia.org/wiki/Laplace_operator" class="uri">https://en.wikipedia.org/wiki/Laplace_operator</a><a href="#fnref5" class="footnote-back">↩︎</a></p></li>
</ol>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
